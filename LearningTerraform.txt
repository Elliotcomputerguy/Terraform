
# What is Terraform

#---------------------------------------------------------------------------------------
Terraform is the infrastructure as code tool from HashiCorp. It is a tool for building, changing, and managing infrastructure in a safe, 
repeatable way. Operators and Infrastructure teams can use Terraform to manage environments with a configuration language called 
the HashiCorp Configuration Language (HCL) for human-readable, automated deployments.
The infrastructure Terraform includes low-level components such as compute instances, 
storage, and networking, as well as high-level components such as DNS entries, SaaS features, etc

https://www.terraform.io/intro/index.html
#---------------------------------------------------------------------------------------

# Workflows

#---------------------------------------------------------------------------------------
A simple workflow for deployment will follow closely to the steps below. 

scope --> Author --> Init --> plan --> apply --> destroy
Scope - Confirm what resources need to be created for a given project.
Author - Create the configuration file in HCL based on the scoped parameters
Initialize - Run terraform init in the project directory with the configuration files. 
This will download the correct provider plug-ins for the project. Plan & Apply - Run terraform plan to 
verify creation process and then terraform apply to create real resources as well as state file that compares future 
changes in your configuration files to what actually exists in your deployment environment.
#---------------------------------------------------------------------------------------

# State Management

#---------------------------------------------------------------------------------------
Terraform creates a state file 'terraform.tfstate' when a project is first initialized with the terraform init command. 
Terraform uses this local state to create plans and make changes to your infrastructure. Prior to any operation, 
Terraform does a refresh to update the state with the real infrastructure. This means that Terraform state is the 
source of truth by which configuration changes are measured. If a change is made or a resource is appended to a 
configuration, Terraform compares those changes with the state file to determine what changes result in a new resource or 
resource modifications.
#---------------------------------------------------------------------------------------

# Write configuration

#---------------------------------------------------------------------------------------
The set of files used to describe infrastructure in Terraform is known as a Terraform configuration. You will write your first 
configuration to define a single AWS EC2 instance. Each Terraform configuration must be in its own working directory. 
Create a directory for your configuration.
#---------------------------------------------------------------------------------------

# Terraform Block

#---------------------------------------------------------------------------------------

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 3.27"
    }
  }

  required_version = ">= 0.14.9"
}

The terraform {} block contains Terraform settings, including the required providers Terraform will use to provision your 
infrastructure. For each provider, the source attribute defines an optional hostname, a namespace, and the provider type. 
Terraform installs providers from the Terraform Registry by default. In this example configuration, the aws provider's source is 
defined as hashicorp/aws, which is shorthand for registry.terraform.io/hashicorp/aws.
You can also set a version constraint for each provider defined in the required_providers block. The version attribute is optional, 
but we recommend using it to constrain the provider version so that Terraform does not install a version of the provider that does 
not work with your configuration. If you do not specify a provider version, Terraform will automatically download the most recent 
version during initialization.
Each module should at least declare the minimum provider version it is known to work with, using the >= version constraint syntax.
The ~> operator is a convenient shorthand for allowing only patch releases within a specific minor release:
Do not use ~> (or other maximum-version constraints) for modules you intend to reuse across many configurations, even if you 
know the module isn't compatible with certain newer versions.
#---------------------------------------------------------------------------------------

# Providers

#---------------------------------------------------------------------------------------

provider "aws" {
  profile = "default"
  region  = "us-west-2"
}

The provider block configures the specified provider, in this case aws. A provider is a plugin that Terraform uses to create and manage 
your resources. The profile attribute in the aws provider block refers Terraform to the AWS credentials stored in your AWS config file, 
which you created when you configured the AWS CLI. Never hard-code credentials or other secrets in your configuration files. 
Like other types of code, you may share and manage your Terraform configuration files using source control, so hard-coding secret 
values can expose them to attackers.
You can use multiple provider blocks in your Terraform configuration to manage resources from different providers. 
You can even use different providers together. For example, you could pass the IP address of your AWS EC2 instance to 
a monitoring resource from DataDog.
#---------------------------------------------------------------------------------------

# Resources

#---------------------------------------------------------------------------------------

resource "aws_instance" "app_server" {
  ami           = "ami-830c94e3"
  instance_type = "t2.micro"

  tags = {
    Name = "ExampleAppServerInstance"
  }
}

Use resource blocks to define components of your infrastructure. A resource might be a physical or virtual component such as an EC2 
instance, or it can be a logical resource such as a Heroku application.
Resource blocks have two strings before the block: the resource type and the resource name. In this example, the resource type 
is aws_instance and the name is app_server. The prefix of the type maps to the name of the provider. In the example configuration, 
Terraform manages the aws_instance resource with the aws provider. Together, the resource type and resource name form a unique ID 
for the resource. For example, the ID for your EC2 instance is aws_instance.app_server.
Resource blocks contain arguments which you use to configure the resource. Arguments can include things like machine sizes, 
disk image names, or VPC IDs. Our providers reference documents the required and optional arguments for each resource. For your 
EC2 instance, the example configuration sets the AMI ID to an Ubuntu image, and the instance type to t2.micro, which qualifies for AWS' 
free tier. It also sets a tag to give the instance a name.
#---------------------------------------------------------------------------------------

# Initialize the directory

#---------------------------------------------------------------------------------------
When you create a new configuration — or check out an existing configuration from version control — you need to initialize the directory 
with terraform init.
Initializing a configuration directory downloads and installs the providers defined in the configuration, which in this case 
is the aws provider.
Terraform downloads the aws provider and installs it in a hidden subdirectory of your current working directory, named .terraform. 
The terraform init command prints out which version of the provider was installed. Terraform also creates a lock file named 
.terraform.lock.hcl which specifies the exact provider versions used, so that you can control when you want to update the providers 
used for your project.
#---------------------------------------------------------------------------------------

# Format and validate the configuration

#---------------------------------------------------------------------------------------
We recommend using consistent formatting in all of your configuration files. The terraform fmt command automatically updates 
configurations in the current directory for readability and consistency.
Format your configuration. Terraform will print out the names of the files it modified, if any. In this case, your configuration 
file was already formatted correctly, so Terraform won't return any file names.

You can also make sure your configuration is syntactically valid and internally consistent by using the 'terraform validate' command.
Validate your configuration. The example configuration provided above is valid, so Terraform will return a success message.
#---------------------------------------------------------------------------------------

# Create infrastructure

#---------------------------------------------------------------------------------------
Apply the configuration now with the terraform apply command. Terraform will print output similar to what is shown below. 
We have truncated some of the output to save space.
Before it applies any changes, Terraform prints out the execution plan which describes the actions Terraform will take in order to 
change your infrastructure to match the configuration. The output format is similar to the diff format generated by tools such as Git. 
The output has a + next to aws_instance.app_server, meaning that Terraform will create this resource. Beneath that, it shows the 
attributes that will be set. When the value displayed is (known after apply), it means that the value won't be known until the 
resource is created. For instance, AWS assigns ARNs to instances when they are created, so Terraform cannot know the value of the 
arn attribute until you apply the change and the AWS provider returns that value from the AWS API.
Terraform will now pause and wait for your approval before proceeding. If anything in the plan seems incorrect or dangerous, 
it is safe to abort here with no changes made to your infrastructure.

In this case the plan is acceptable, so type yes at the confirmation prompt to proceed. Executing the plan will take a few minutes 
since Terraform waits for the EC2 instance to become available.
#---------------------------------------------------------------------------------------

# Inspect state

#---------------------------------------------------------------------------------------
When you applied your configuration, Terraform wrote data into a file called terraform.tfstate. Terraform stores the IDs and properties 
of the resources it manages in this file, so that it can update or destroy those resources going forward.
The Terraform state file is the only way Terraform can track which resources it manages, and often contains sensitive information, 
so you must store your state file securely and distribute it only to trusted team members who need to manage your infrastructure. 
In production, we recommend storing your state remotely with Terraform Cloud or Terraform Enterprise. Terraform also supports several 
other remote backends you can use to store and manage your state.
#---------------------------------------------------------------------------------------

Manually Managing State

#---------------------------------------------------------------------------------------
Terraform has a built-in command called terraform state for advanced state management. For example, you may want a 
list of the resources in your project's state, which you can get by using the list subcommand. terraform state list
#---------------------------------------------------------------------------------------

# changing infrastructure

#---------------------------------------------------------------------------------------
resource "aws_instance" "app_server" {
    -  ami           = "ami-0a6aae90571909e92"
    +  ami           = "ami-08d70e59c07c61a3a"
    instance_type = "t2.micro"

Update the ami of your instance. Change the aws_instance.app_server resource under the provider block in main.tf, by replacing the current 
AMI ID with a new one. Remove + and - as they are a representation of what to change.
#---------------------------------------------------------------------------------------

# Apply Changes

#---------------------------------------------------------------------------------------
After changing the configuration, run terraform apply again to see how Terraform will apply this change to the existing resources.
The prefix -/+ means that Terraform will destroy and recreate the resource, rather than updating it in-place. Terraform can update 
some attributes in-place (indicated with the ~ prefix), but changing the AMI for an EC2 instance requires recreating it. 
Terraform handles these details for you, and the execution plan displays what Terraform will do.
Additionally, the execution plan shows that the AMI change is what required your resource to be replaced. Using this information, 
you can adjust your changes to to avoid destructive updates if necessary.
Once again, Terraform prompts for approval of the execution plan before proceeding. Answer yes to execute the planned steps.
#---------------------------------------------------------------------------------------

# Destroy

#---------------------------------------------------------------------------------------
The terraform destroy command terminates resources managed by your Terraform project. This command is the reverse of terraform apply 
in that it terminates all the resources specified in your Terraform state. It does not destroy resources running elsewhere that are 
not managed by the current Terraform project.
#---------------------------------------------------------------------------------------

# Store Remote State

#---------------------------------------------------------------------------------------
Terraform remote backends allow Terraform to use a shared storage space for state data. The Terraform Cloud remote backend 
also allows teams to easily version, audit, and collaborate on infrastructure changes. Terraform Cloud also securely stores variables, 
including API tokens and access keys. It provides a safe, stable environment for long-running Terraform processes.
#---------------------------------------------------------------------------------------

# Log in to Terraform Cloud from the CLI

#---------------------------------------------------------------------------------------
In order to authenticate with Terraform Cloud, run the terraform login subcommand. Terraform will prompt you to confirm that you want 
to authenticate by typing yes in your terminal.
#---------------------------------------------------------------------------------------


# Terraform HCL Language guide

#---------------------------------------------------------------------------------------
https://www.terraform.io/docs/language/expressions/references.html
#---------------------------------------------------------------------------------------